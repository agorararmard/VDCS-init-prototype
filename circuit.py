import random
from Crypto.Hash import MD5
from Crypto.Cipher import Salsa20

LBL_LENGTH = 32

def enc(key, data):
    """
    - 16-byte key : byte object
    - data : bytes object
    returns a bytes object
    """
    cipher = Salsa20.new(key)
    md5hash = MD5.new(data).digest()
    msg = cipher.nonce + cipher.encrypt(md5hash+data)
    return msg

def dec(key, msg):
    """
    key, msg are a bytes object
    returns bytes object
    """
    if not msg: # bad, very bad, use exceptions
        return False
    msg_nonce = msg[:8]
    ciphertext = msg[8:]
    cipher = Salsa20.new(key=key, nonce=msg_nonce)
    plaintext = cipher.decrypt(ciphertext)
    md5hash = plaintext[:16]
    data = plaintext[16:]
#    print(md5hash)
#    print(data)
    if md5hash != MD5.new(data).digest():
        return False
    else:
        return data

class circuit:
    """
    This will be generalized using graphs later, for now it's just a silly
    1-bit gate
    """

    def __init__(self, bf_1bit, cid):
        """
        - bf_1bit is a single-bit boolean function (example, a&b, a|b, ...)
        - cid is the computation id generated by the client
        """
        # build table
        self.table = [0]*4
        self.garbled = False
        self.cid = cid
        self.arr_in = [0]*4 #a0, a1, b0, b1
        self.arr_out = [0]*2 #z0, z1
        for i in range(4):
            self.table[i] = bf_1bit(i>>0x1, i&0x1)

    def YaoGarbledCkt_in(self, R1in):
        """
        returns the labels associated with the input wires without evaluating
        the whole garbled circuit GC1
        """
        return [MD5.new(bytes(R1in+i)).digest() for i in range(4)]

    def YaoGarbledCkt_out(self, R1out):
        """
        returns the labels associated with the output wires without evaluating
        the whole garbled circuit GC1
        """
        # assumes input was generated first (5th, 6th random seed)
        # to be adjusted later when we find an appropriate PRF
        return [MD5.new(bytes(R1out+i)).digest() for i in range(2)]

    def YaoGarbledCkt(self, R1in, R1out, R1gc):
        """
        - R1 is a random seed (more accurately, the one sent to server #1)
        - This function transforms the table to garbled form, and generates the
        input wire and output wire keys
        """
        self.arr_in = self.YaoGarbledCkt_in(R1in)
        self.arr_out = self.YaoGarbledCkt_out(R1out)
        for i in range(len(self.table)):
            a = self.arr_in[0+(i>>1)]
            b = self.arr_in[2+(i&1)]
            z = self.arr_out[self.table[i]]
            self.table[i] = enc(a, enc(b, z))
        random.seed(0) # time
        random.shuffle(self.table)
        self.garbled = True

    def eval(self, a, b):
        """
        a, b are keys
        """
        for i in range(len(self.table)):
            # need exceptions
            result = dec(b, dec(a, self.table[i]))
            if result:
                break

        return result

    def reRand_in(self, R):
        pass

    def reRand(self, R):
        pass



# TESTING
def AND(a, b):
    return a&b

circ = circuit(AND, 0)
circ.YaoGarbledCkt(1, 2, 3)
a0, a1, b0, b1 = circ.YaoGarbledCkt_in(1)
z0, z1 = circ.YaoGarbledCkt_out(2)

z = circ.eval(a1, b1)

if z == z0:
    print(0)
elif z == z1:
    print(1)
else:
    print("I was tricked:(")